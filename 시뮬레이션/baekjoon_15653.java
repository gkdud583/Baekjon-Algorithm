import java.util.HashMap;import java.util.Map;import java.util.Scanner;enum State {  EMPTY("."),  WALL("#"),  EXIT("O"),  RED("R"),  BLUE("B");  private String s;  State(String s) {    this.s = s;  }  public static State getState(String s) {    State[] values = values();    for (State state : values) {      if (state.s.equals(s)) {        return state;      }    }    return null;  }}class Marble {  private int y;  private int x;  private State color;  public Marble(int y, int x, State color) {    this.y = y;    this.x = x;    this.color = color;  }  public int getY() {    return y;  }  public int getX() {    return x;  }  public State getColor() {    return color;  }  public boolean isExit() {    if (baekjoon_15653.map[y][x] == State.EXIT) {      return true;    }    return false;  }  public boolean roll(int action, int R, int C, State[][] map) {    int fy = y, fx = x;    int by = y, bx = x;    boolean isMovable = false;    while (true) {      y = y + baekjoon_15653.DY[action];      x = x + baekjoon_15653.DX[action];      if (!isAccessible(y, x, R, C, map)) {        break;      }      isMovable = true;      by = y;      bx = x;      if (isExit()) {        break;      }    }    y = by;    x = bx;    map[fy][fx] = State.EMPTY;    map[y][x] = color;    return isMovable;  }  private boolean isAccessible(int y, int x, int R, int C, State[][] map) {    if (isOutOfArray(y, x, R, C)) {      return false;    }    if (isExit() || map[y][x] == State.EMPTY) {      return true;    }    return false;  }  private boolean isOutOfArray(int y, int x, int R, int C) {    if (y < 0 || x < 0 || y >= R || x >= C) {      return true;    }    return false;  }}public class baekjoon_15653 {  public static final int ACTION_SIZE = 4;  public static final int DY[] = {-1, 1, 0, 0};  public static final int DX[] = {0, 0, -1, 1};  public static State map[][];  public static Map<String, Integer> dp = new HashMap<>();  public static final int INITIAL_VALUE = 987654321;  public static int answer = INITIAL_VALUE;  public static void main(String[] args) {    Scanner sc = new Scanner(System.in);    String[] input = sc.nextLine().split(" ");    int R = Integer.parseInt(input[0]);    int C = Integer.parseInt(input[1]);    map = new State[R][C];    Marble red = null, blue = null;    for (int i = 0; i < R; i++) {      input = sc.nextLine().split("");      for (int j = 0; j < C; j++) {        map[i][j] = State.getState(input[j]);        if (map[i][j] == State.RED) {          red = new Marble(i, j, State.RED);        } else if (map[i][j] == State.BLUE) {          blue = new Marble(i, j, State.BLUE);        }      }    }    solve(0, red, blue, R, C, copyMap(R, C, map));    if (answer == INITIAL_VALUE) {      System.out.println(-1);      return;    }    System.out.println(answer);  }  public static void solve(int count, Marble red, Marble blue, int R, int C,    State[][] tempMap) {    for (int i = 0; i < baekjoon_15653.ACTION_SIZE; i++) {      Marble newRed = copyMarble(red);      Marble newBlue = copyMarble(blue);      State[][] newMap = copyMap(R, C, tempMap);      boolean result = rollMarble(i, R, C, newRed, newBlue, newMap);      if (!result) {        continue;      }      if (newBlue.isExit()) {        continue;      }      if (newRed.isExit()) {        answer = Math.min(answer, count + 1);        return;      }      if (isNotAnswer(newRed, newBlue, count + 1)) {        continue;      }      solve(count + 1, newRed, newBlue, R, C, newMap);    }  }  private static boolean rollMarble(int action, int R, int C, Marble red, Marble blue,    State[][] map) {    boolean redFirst = false;    switch (action) {      case 0: {        if (blue.getY() > red.getY()) {          redFirst = true;        }        break;      }      case 1: {        if (blue.getY() < red.getY()) {          redFirst = true;        }        break;      }      case 2: {        if (blue.getX() > red.getX()) {          redFirst = true;        }        break;      }      case 3: {        if (blue.getX() < red.getX()) {          redFirst = true;        }        break;      }    }    boolean redIsMovable = false;    boolean blueIsMovable = false;    if (redFirst) {      redIsMovable = red.roll(action, R, C, map);      blueIsMovable = blue.roll(action, R, C, map);    } else {      blueIsMovable = blue.roll(action, R, C, map);      redIsMovable = red.roll(action, R, C, map);    }    return redIsMovable || blueIsMovable;  }  private static boolean isNotAnswer(Marble red, Marble blue, int count) {    StringBuffer sb = new StringBuffer();    sb.append(red.getY()).append(red.getX()).append(blue.getY()).append(blue.getX());    if (dp.containsKey(sb.toString())) {      if (dp.get(sb.toString()) <= count) {        return true;      }      dp.remove(sb.toString());    }    dp.put(sb.toString(), count);    return false;  }  private static Marble copyMarble(Marble marble) {    return new Marble(marble.getY(), marble.getX(), marble.getColor());  }  private static State[][] copyMap(int R, int C, State[][] src) {    State destMap[][] = new State[R][C];    for (int i = 0; i < R; i++) {      for (int j = 0; j < C; j++) {        destMap[i][j] = src[i][j];      }    }    return destMap;  }}