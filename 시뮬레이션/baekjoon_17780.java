import java.util.ArrayDeque;import java.util.Deque;import java.util.Scanner;class Horse {  private int num;  private int y;  private int x;  private int d;  // 오른쪽 왼쪽 위 아래  public static final int DY[] = {0, 0, 0, -1, 1};  public static final int DX[] = {0, 1, -1, 0, 0};  public static final int REVERSE_DIRECTION[] = {0, 2, 1, 4, 3};  public Horse(int num, int y, int x, int d) {    this.num = num;    this.y = y;    this.x = x;    this.d = d;  }  public int getY() {    return y;  }  public int getX() {    return x;  }  public boolean isSame(Horse horse) {    return this.num == horse.num;  }  public void move(int N) {    if (baekjoon_17780.horseMap[y][x].size() >= 2) {      if (!isSame(baekjoon_17780.horseMap[y][x].getFirst())) {        return;      }    }    int ny = y + DY[d];    int nx = x + DX[d];    if (isOutOfArray(ny, nx, N) || baekjoon_17780.map[ny][nx] == 2) {      d = REVERSE_DIRECTION[d];      ny = y + DY[d];      nx = x + DX[d];      if (isOutOfArray(ny, nx, N) || baekjoon_17780.map[ny][nx] == 2) {        return;      }    }    if (baekjoon_17780.map[ny][nx] == 1) {      Deque<Horse> horses = baekjoon_17780.horseMap[y][x];      while (!horses.isEmpty()) {        Horse horse = horses.removeLast();        baekjoon_17780.horseMap[ny][nx].add(horse);        horse.setLocation(ny, nx);      }      return;    }    // 흰색    Deque<Horse> horses = baekjoon_17780.horseMap[y][x];    while (!horses.isEmpty()) {      Horse horse = horses.removeFirst();      baekjoon_17780.horseMap[ny][nx].add(horse);      horse.setLocation(ny, nx);    }  }  private boolean isOutOfArray(int y, int x, int N) {    if (y < 1 || x < 1 || y > N || x > N) {      return true;    }    return false;  }  private void setLocation(int y, int x) {    this.y = y;    this.x = x;  }}public class baekjoon_17780 {  public static Deque<Horse> horseMap[][];  public static int map[][];  public static Horse[] horses;  public static final Scanner SC = new Scanner(System.in);  public static void main(String[] args) {    int N = SC.nextInt();    int K = SC.nextInt();    initHorseMap(N);    initMap(N);    initHorse(K);    System.out.println(solve(N, K));  }  private static void initMap(int N) {    map = new int[N + 1][N + 1];    for (int i = 1; i <= N; i++) {      for (int j = 1; j <= N; j++) {        map[i][j] = SC.nextInt();      }    }  }  private static void initHorse(int K) {    horses = new Horse[K + 1];    for (int i = 1; i <= K; i++) {      horses[i] = new Horse(i, SC.nextInt(), SC.nextInt(), SC.nextInt());      horseMap[horses[i].getY()][horses[i].getX()].add(horses[i]);    }  }  private static void initHorseMap(int N) {    horseMap = new ArrayDeque[N + 1][N + 1];    for (int i = 1; i <= N; i++) {      for (int j = 1; j <= N; j++) {        horseMap[i][j] = new ArrayDeque<>();      }    }  }  private static int solve(int N, int K) {    int turn = 0;    boolean gameOver = false;    while (true) {      turn++;      for (int horse = 1; horse <= K; horse++) {        horses[horse].move(N);        if (isGameOver(horses[horse].getY(), horses[horse].getX())) {          gameOver = true;          break;        }      }      if (gameOver) {        break;      }      if (turn > 1000) {        return -1;      }    }    return turn;  }  private static boolean isGameOver(int y, int x) {    return horseMap[y][x].size() >= 4;  }}